---
author: shupeng.lisp
comments: true
date: 2012-10-04 10:44:39
layout: post
slug: zookeeper_paper_notes
title: ZooKeeper论文阅读笔记
wordpress_id: 54
categories: [技术]
---

论文原文：[ZooKeeper: Wait-free coordination for Internet-scale systems](http://static.usenix.org/event/usenix10/tech/full_papers/Hunt.pdf)


#### 总论


ZooKeeper是一个用来协调分布式应用程序进程的服务。由于是关键基础设施的一部分，为了能在客户端建设更为复杂的协调原语，ZooKeeper定位于提供一个简单而高性能的内核。它结合了多副本、集中式的分组消息、共享注册、分布式锁服务。ZooKeeper暴露的接口具有带有事件驱动机制的共享注册的无等待特征，利用这一点来提供简单而强大的协调服务，这类似于分布式文件系统的缓存独立。

除了无等待特性之外，ZooKeeper保证了在每个客户端上执行请求的FIFO执行，并保证改变ZooKeeper状态的所有请求的线性一致性。这些设计决策使得由本地存储来支持读请求的高性能处理管道变得可行。根据目标负载，读写比为2:1到100:1每秒可以支持几万到几十万个事务。

ZooKeeper的设计改变了由服务器端维护的特有原语这一做法，而是改由服务器端提供API，由客户端来实现原语。服务器端只负责协调内核，新有的原语不需要改变服务端的核心，。而客户端可以根据应用的需求来自己适应协调，而不是将开发者限制在一个固定的原语组。

Zookeeper不使用阻塞（如使用锁），主要出于两点考虑，一是使用阻塞会降低速度；其二是慢速或者有错误的客户端会对较快的客户端造成负面影响。并且，如果处理请求依赖于其他客户端的响应和失效控制，会变得非常复杂。因此，zookeeper实现API，并管理类似于文件系统中层次关系组织起来的无等待数据对象。

Zookeeper的API命名上，开起来类似于没有lock、close、open操作的chubby。与其他基于阻塞原语相比，zookeeper的最大不同之处就是实现无等待的数据对象。

Zookeeper聚集了多个服务器，因此具有高可用和高性能。



	
  * 所有操作的FIFO客户端序，使得客户端可以异步提交操作，这就是意味着一次有多个操作。

	
  * 线性写是有zab协议保证的，zab协议是一个基于leader的原子广播协议。


以上两点保证了有效的服务实践。 无等待具有性能和容错的优势，加上其它保证，就构成协调功能。

在客户端缓存数据是增强读性能的重要方式。Watch机制：客户端cache数据而不用直接管理客户端。
  <!--break-->

#### ZooKeeper服务


ZooKeeper给客户端暴露服务，由客户端使用ZooKeeper服务接口并自己管理网络连接。

ZooKeeper中的数据节点称为Znode，它们是层次组织的数据对象，他们可以存储数据，但通常都是协调信息的元数据（这是因为ZooKeeper天生就不是设计来存储大数据的，有了HDFS，不需要存储大数据）。Znode的层级结构决定了除开ephemeral（短暂的）类型的znode外，都可以有孩子节点。服务端提供给客户端一组znode，而客户端通过API来操作这些znode。

ZooKeeper层次命名空间的数据模型可以为不同的应用命名空间分配子树，并可以给这些子树设置访问权限，而对于层次概念，在客户端展现的是目录的概念。

ZooKeeper还具有会话（session）表示，会话是在连接之后初始化建立的，具有超时属性，在一个会话中，有一系列的反应操作执行的状态更新，并且，会话可以使客户在多个服务器上透明切换。

ZooKeeper服务没有句柄（handle），这样做有两个好处：1，简化了API，不需要open、close这些API；2，消除了server需要维护的额外状态。

ZooKeeper提供了担保，这主要包括两个基本序列保证：FIFO客户端序和线性写，这里的线性是A-线性（也就是异步线性）。

关于异步线性的一个场景分析：

在重新选举leader时，在新leader更新时，不期望配置被其他参与者读取，如果新leader在配置更新之前死亡，也不期望这些配置信息被读取，zookeeper可以采取定义一个ready的znode，并在之上设置watch。如果除了使用zookeeper之外，还有使用其他通信管道的话，sync方法可以帮助来同步配置信息的更新。此外，zookeeper还提供了活性和一致性保证。

Zookeeper提供了同步/异步两种方式，所有方法都有一个同步/异步的版本，同步指的是单一操作无并发执行，采取必要的zookeeper调用和阻塞；异步指的是多个操作并发执行。Sync操作有点类似强行同步一次的意思。


#### Zookeeper的原语示例




###### watch允许有效等待，因此可以实现阻塞。





	
  *  配置管理；

	
  *  会合：不知道最终的系统配置是什么；

	
  *   成员分组；

	
  *   简单锁；

	
  *   无羊群效应的简单锁；

	
  *   读写锁；

	
  *   双栅；




#### ZooKeeper实现


请求处理器：



	
  *  消息层是原子的。

	
  *   事务是幂等的，在接受写请求时，计算系统的未来状态，并传输到一个包含这个状态事务中。这是由于可能存在还没有提交到数据库的事务。


原子广播：

	
  *   所有更新ZooKeeper状态的请求都转发给leader。这里使用的是zab协议。

	
  *   ZooKeeper保持请求处理管道满来保证高吞吐。

	
  *   Zab保证由一个leader广播的改变以发送的顺序广播，所有之前leader的改变被发送到一个已建立的leader在该leader广播自己的改变之前。

	
  *   事务是幂等的（保证有序的情况下，重发不影响）。

	
  *  几个细节：

	
    *   采用TCP协议，消息序由网络保证；

	
    *   由Zab选举leader，而创建事务的过程是一样的，在内存数据库之前跟踪提案委前写log，这样不用朝磁盘写两次。





副本数据库：

	
  *   内存数据库中包含整个数据数，这个大小可配置，默认为1MB。

	
  *   在更新时，先log更新到磁盘，然后到内存数据库。

	
  *   和Chubby一样，保持一个提交操作的回放log并生成内存数据库的周期性快照。

	
  *   读请求由连接的server的本地磁盘处理。

	
  *   改变系统状态的（更新）请求统一由协议处理。


服务端-客户端交互

	
  *   在server处理写请求时，将发送并清除通知。Server本地处理通知，可以保证通知的先后顺序。

	
  *   读请求在每个server本次处理。这在以读为主的负载中，将极大提高性能。

	
  *   一个不足就是读操作中，快读不能保证先后顺序。全局的sync操作可以解决这个问题。由于leader选举算法，也不需要院子的广播sync。

	
  *   持久性保证，客户端切换server时，只会切换到包含了客户端最后zxid的server。

	
  *   Session过期时的策略，在session限制到超时的1/3时，客户端发送一个心跳信息，如果在2/3时还没有回应。则切换个新的server。


