---
layout: post
title: "重读算法---最大公约数与平方根"
description: "最大公约数 平方根 欧几里德算法 牛顿迭代法"
category: 算法
tags: [最大公约数 平方根 欧几里德算法 牛顿迭代法]
---
{% include JB/setup %}


## 一、 最大公约数

### 1.1 Wiki定义

>[最大公约数](http://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0)（Greatest Common Divisor，简写为G.C.D.；或Highest Common Factor，简写为H.C.F.）
指某几个整数共有约数中最大的一个。
求两个整数最大公约数主要的方法：
<!--break-->
>+ 列举法：各自列出约数，再找出最大的公约数。
>+ 质约数分解法：两数各作质约数分解，然后取出同样有的项乘起来。
>+ 短除法
>+ 辗转相除法（扩展版）：常使用于直观上不容易判别公约数的场合。

### 1.2 欧几里德算法

[欧几里德算法](http://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95)，也就是上面所说的`辗转相除法`算是GCD问题的一个经典案例，它的一个简要描述如下:

>辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。

> 例如，252和105的最大公约数是21（252 = 21 × 12；105 = 21 × 5）；因为252 − 105 = 147，所以147和105的最大公约数也是21。

### 1.3 欧几里德算法的一种实现(Java)

    public int gcd(int m, int n) {
        if (n == 0) {
            return m;
        }
        if (m % n == 0) {
            return n;
        } else {
            return gcd(n, m % n);
        }
    }


## 二、 平方根

### 2.1 Wiki定义
>[平方根](http://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%A0%B9)
> 对于非负实数来说，平方根，是指自乘结果等于的实数，表示为±（√x），读作正负根号下x或x的平方根。其中的非负的平方根称为算术平方根。正整数的平方根通常是无理数。

### 2.2 平方根的特性
平方根的平方==自身，也就是：

a=b^2
则
b=sqrt(a)

### 2.3 平方根求法
+ 中算开方
+ 长除式算法
    这个算法的原理是(a+b)^2=a^2+b^2+2ab=a^2+b(b+2a)。
+ 牛顿法
    利用原理：如果要求***S(S>1)***的平方根，选取***1<x0<S***:
2x^(n+1)x^n=x^(2n)+S
+ 连分法
+ 巴比伦方法
+ 重复的算术运算
+ 佩尔方程
+ 尺规作图

### 2.4 牛顿法的一种实现

    /** 计算平方根(牛顿迭代法) */
    public static double sqrt(double c) {
        if (c < 0) {
            return Double.NaN;
        }
        double err = 1e-15;//精度
        double t = c;
        while (Math.abs(t - c / t) > err * t) {
            t = (c / t + t) / 2.0;
        }
        return t;
    }

## 三、 小结
重读算法，发现很多看似平常的问题，都存在着很多解，而在这些解后面，是各种不断凝聚的思想，而思想的出发点就是**问题从哪里来? 需要回归到哪里去?**，比如这里的gcd算法中，就是在让数不断缩小的同时保持gcd的特性，同样，在开平方根的时候也是一样，以**牛顿法为例**，总是利用了特性！因此，在设计算法的时候，总是要从问题的出发点和验证点两方去思考！


